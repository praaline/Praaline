#include <QDebug>
#include <QString>
#include <QList>
#include <QPointer>
#include <QMap>
#include <QDebug>
#include <QElapsedTimer>

#include "PraalineCore/Corpus/Corpus.h"
#include "PraalineCore/Annotation/AnnotationTierGroup.h"
#include "PraalineCore/Annotation/IntervalTier.h"
#include "PraalineCore/Datastore/CorpusRepository.h"
#include "PraalineCore/Datastore/AnnotationDatastore.h"
#include "PraalineCore/Interfaces/Praat/PraatTextGrid.h"
#include "PraalineCore/Diff/DiffIntervals.h"
using namespace Praaline::Core;

#include "PFCAlignmentEvaluation.h"

struct PFCAlignmentEvaluationData {
    QStringList regionCodes;
    QStringList styles;
    QMap<QString, QMap<QString, PFCAlignmentEvaluation::EvaluationResults> > resultsPivot;
};

PFCAlignmentEvaluation::PFCAlignmentEvaluation() :
    d(new PFCAlignmentEvaluationData())
{
    d->regionCodes << "11a" << "12a" << "13a" << "13b" << "21a" << "31a" << "38a" << "42a" << "44a" << "50a"
                   << "54b" << "61a" << "64a" << "69a" << "75c" << "75x" << "81a" << "85a" << "92a" << "974"
                   << "aba" << "aca" << "bfa" << "bga" << "bla" << "bta" << "caa" << "cia" << "cqa" << "cqb"
                   << "cya" << "maa" << "rca" << "sca" << "sga" << "sna" << "sva";
    d->styles << "conv" << "text";
    pivotReset();
}

PFCAlignmentEvaluation::~PFCAlignmentEvaluation()
{
    delete d;
}

QString PFCAlignmentEvaluation::EvaluationResults::toString() const
{
    QString ret;
    QString sep = "\t";
    ret.append(ID).append(sep).append(groupID).append(sep);
    ret.append(regionData).append(sep).append(regionModel).append(sep);
    if (!speakerID.isEmpty()) ret.append(speakerID).append(sep);
    ret.append(QString::number(insertions)).append(sep);
    ret.append(QString::number(deletions)).append(sep);
    ret.append(QString::number(phonemesLessThan20ms)).append(sep);
    ret.append(QString::number(phonemesLessThan40ms)).append(sep);
    ret.append(QString::number(phonemesTotal)).append(sep);
    ret.append(QString::number(percentageLessThan20ms())).append(sep);
    ret.append(QString::number(percentageLessThan40ms())).append(sep);
    if (!filenameComparative.isEmpty()) ret.append(filenameComparative);
    ret.append("\n");
    return ret;
}

QList<PFCAlignmentEvaluation::EvaluationResults>
PFCAlignmentEvaluation::evaluate(Praaline::Core::CorpusCommunication *com,
                                 const QString &directoryTextGridA, const QString nameA,
                                 const QString &directoryTextGridB, const QString nameB,
                                 const QString &directoryTextgridCompare)
{
    QList<EvaluationResults> results;
    if (!com) return results; // No Communication
    if (com->recordings().isEmpty()) return results; // QString("No Recordings for %1").arg(com->ID());
    CorpusRecording *rec = com->recordings().first();
    if (!rec) return results; // "No Recording";
    QString annotationID = com->ID();
    InterfaceTextFile::setDefaultEncoding("UTF-8");
    QString style = (com->ID().endsWith("t")) ? "text" : "conv";
    SpeakerAnnotationTierGroupMap tiersAll = com->repository()->annotations()->
            getTiersAllSpeakers(annotationID, QStringList() << "segment" << "tok_min");
    // For each speaker
    foreach (QString speakerID, tiersAll.keys()) {
        // Accumulate for output txg
        QList<Interval *> intervals_phone_A;
        QList<Interval *> intervals_phone_B;
        QList<Interval *> intervals_words_A;
        QList<Interval *> intervals_words_B;
        // From the database
        AnnotationTierGroup *tiers = tiersAll.value(speakerID);
        IntervalTier *tier_segment = tiers->getIntervalTierByName("segment");
        if (!tier_segment) continue;
        IntervalTier *tier_tok_min = tiers->getIntervalTierByName("tok_min");
        if (!tier_tok_min) continue;
        // For each utterance
        int indexUtterance = tier_segment->count() - 1;
        while (indexUtterance >= 0) {
            if (tier_segment->at(indexUtterance)->isPauseSilent()) { indexUtterance--; continue; }
            Interval *utterance = tier_segment->at(indexUtterance);
            RealTime timeFrom = utterance->tMin();
            QPair<int, int> tokenIndices = tier_tok_min->getIntervalIndexesContainedIn(tier_segment->at(indexUtterance));
            int tokenIndexFrom = tokenIndices.first;
            // Find alignment textgrids
            QString filenameAligned = QString("%1_%2_%3.TextGrid").arg(QFileInfo(rec->filePath()).baseName()).arg(speakerID).arg(tokenIndexFrom);
            // Open textgrids generated by the aligner
            AnnotationTierGroup *txgA = new AnnotationTierGroup;
            PraatTextGrid::load(directoryTextGridA + "/" + speakerID + "/" + filenameAligned, txgA);
            AnnotationTierGroup *txgB = new AnnotationTierGroup;
            PraatTextGrid::load(directoryTextGridB + "/" + speakerID + "/" + filenameAligned, txgB);
            IntervalTier *tier_phone_A = txgA->getIntervalTierByName("phones");
            IntervalTier *tier_words_A = txgA->getIntervalTierByName("words");
            IntervalTier *tier_phone_B = txgB->getIntervalTierByName("phones");
            IntervalTier *tier_words_B = txgB->getIntervalTierByName("words");
            if ((!tier_phone_A) || (!tier_words_A) || (!tier_phone_B) || (!tier_words_B)) {
                delete txgA; delete txgB; indexUtterance--; continue;
            }
            foreach (Interval *intv, tier_phone_A->intervals()) { if (intv->text() == "sil") continue; if (intv->text() == "sp") continue; intervals_phone_A.prepend(new Interval(intv->tMin() + timeFrom, intv->tMax() + timeFrom, intv->text())); }
            foreach (Interval *intv, tier_words_A->intervals()) { if (intv->text() == "sil") continue; if (intv->text() == "sp") continue; intervals_words_A.prepend(new Interval(intv->tMin() + timeFrom, intv->tMax() + timeFrom, intv->text())); }
            foreach (Interval *intv, tier_phone_B->intervals()) { if (intv->text() == "sil") continue; if (intv->text() == "sp") continue; intervals_phone_B.prepend(new Interval(intv->tMin() + timeFrom, intv->tMax() + timeFrom, intv->text())); }
            foreach (Interval *intv, tier_words_B->intervals()) { if (intv->text() == "sil") continue; if (intv->text() == "sp") continue; intervals_words_B.prepend(new Interval(intv->tMin() + timeFrom, intv->tMax() + timeFrom, intv->text())); }
            delete txgA; delete txgB;
            // QString done = directoryTextGridA + filenameAligned + "\t" + directoryTextGridB + filenameAligned + "\t" + QString::number(timeFrom.toDouble());
            indexUtterance--;
        }
        // Create tiers for comparative textgrid
        IntervalTier *tier_phone_A = new IntervalTier(QString("phone-%1").arg(nameA), intervals_phone_A);
        IntervalTier *tier_phone_B = new IntervalTier(QString("phone-%1").arg(nameB), intervals_phone_B);
        IntervalTier *tier_words_A = new IntervalTier(QString("words-%1").arg(nameA), intervals_words_A);
        IntervalTier *tier_words_B = new IntervalTier(QString("words-%1").arg(nameB), intervals_words_B);
        tier_phone_A->fillEmptyWith("", "_"); tier_phone_A->mergeIdenticalAnnotations("_");
        tier_phone_B->fillEmptyWith("", "_"); tier_phone_B->mergeIdenticalAnnotations("_");
        AnnotationTierGroup *txg_comparative = new AnnotationTierGroup();
        txg_comparative->addTier(tier_phone_A);
        txg_comparative->addTier(tier_phone_B);
        txg_comparative->addTier(tier_words_A);
        txg_comparative->addTier(tier_words_B);
        QString filenameTxgComparative = QString("%1_%2.TextGrid").arg(com->ID()).arg(speakerID);
        QDir comparativeDir(directoryTextgridCompare);
        if (!comparativeDir.exists()) comparativeDir.mkpath(".");
        PraatTextGrid::save(directoryTextgridCompare + "/" + filenameTxgComparative, txg_comparative);
        // Diff phonemes tiers and calculate percentages
        dtl::Ses<Interval *>::sesElemVec sesSequence;
        sesSequence = DiffIntervals::intervalDiff(tier_phone_A->intervals(), tier_phone_B->intervals(), false).getSes().getSequence();
        int insertions(0), deletions(0);
        int phonemesLessThan20ms(0), phonemesLessThan40ms(0), phonemesTotal(0);
        for (size_t i = 0; i < sesSequence.size(); ++i) {
            dtl::Ses<Interval *>::sesElem elem = sesSequence[i];
            Interval *phoneA = (elem.second.beforeIdx > 0) ? tier_phone_A->intervals().at(elem.second.beforeIdx - 1) : nullptr;
            Interval *phoneB = (elem.second.afterIdx > 0) ? tier_phone_B->intervals().at(elem.second.afterIdx - 1) : nullptr;
            dtl::edit_t editType = elem.second.type;
            if (editType == dtl::SES_COMMON) {
                // qDebug() << editType << phoneA->tMin().toDouble() << phoneA->text() << phoneB->tMin().toDouble() << phoneB->text();
                RealTime delta = (phoneA->tCenter() > phoneB->tCenter()) ? phoneA->tCenter() - phoneB->tCenter() :
                                                                           phoneB->tCenter() - phoneA->tCenter();
                if (delta < RealTime::fromMilliseconds(20)) phonemesLessThan20ms++;
                if (delta < RealTime::fromMilliseconds(40)) phonemesLessThan40ms++;
                phonemesTotal++;
            }
            else if (editType == dtl::SES_ADD) insertions++;
            else if (editType == dtl::SES_DELETE) deletions++;
        }
        // Post result
        EvaluationResults eval;
        eval.ID = com->ID();
        eval.groupID = style;
        eval.speakerID = speakerID;
        eval.regionData = nameA;
        eval.regionModel = nameB;
        eval.insertions = insertions;
        eval.deletions = deletions;
        eval.phonemesLessThan20ms = phonemesLessThan20ms;
        eval.phonemesLessThan40ms = phonemesLessThan40ms;
        eval.phonemesTotal = phonemesTotal;
        eval.filenameComparative = filenameTxgComparative;
        results << eval;
        delete txg_comparative;
    }
    qDeleteAll(tiersAll);
    return results;
}

QString PFCAlignmentEvaluation::evaluate_Individual_RegionStyle(Praaline::Core::CorpusCommunication *com)
{
    // Communication information
    QString region = com->ID().left(3);
    QString style = (com->ID().endsWith("t")) ? "text" : "conv";

    // 1. Individual: /mnt/hgfs/DATA/PFCALIGN/MFA_individual/11aal1t/align_11aal1t/11aal1_X
    QString directoryTxgIndiv = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_individual/%1/align_%1").arg(com->ID());
    // 2. Region-Style: /mnt/hgfs/DATA/PFCALIGN/MFA_region_style/11a_text/align_11a_text/11aal1_X
    QString directoryTxgRegSty = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_region_style/%1_%2/align_%1_%2").arg(region).arg(style);
    // Comparison results
    QString directoryCompare = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_evaluate/%1_%2_indiv").arg(region).arg(style);
    // do it
    QList<EvaluationResults> results = evaluate(com, directoryTxgIndiv, "indiv", directoryTxgRegSty, "regsty", directoryCompare);
    QString ret;
    foreach (EvaluationResults eval, results) { ret.append(eval.toString()).append("\n"); }
    if (!ret.isEmpty()) ret.chop(1);
    return ret;
}

QString PFCAlignmentEvaluation::evaluate_RegionStyle_RegionStyle(Praaline::Core::CorpusCommunication *com)
{
    QString ret;
    // Communication information
    QString regionA = com->ID().left(3);
    QString style = (com->ID().endsWith("t")) ? "text" : "conv";

    foreach (QString regionB, d->regionCodes) {
        if (regionA == regionB) continue;
        // Region-Style: /mnt/hgfs/DATA/PFCALIGN/MFA_region_style_align/11a_text_11a_text/{speakerID}/{textgrids}
        QString directoryTxgRegionA = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_region_style_align/%2_%1_%3_%1").arg(style).arg(regionA).arg(regionA);
        QString directoryTxgRegionB = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_region_style_align/%2_%1_%3_%1").arg(style).arg(regionA).arg(regionB);
        // Comparison results
        QString directoryCompare = QString("/mnt/hgfs/DATA/PFCALIGN/MFA_evaluate/%2_%1_%3_%1").arg(style).arg(regionA).arg(regionB);
        QDir comparativeDir(directoryCompare);
        if (!comparativeDir.exists()) comparativeDir.mkpath(".");
        // Evaluate
        QList<EvaluationResults> results = evaluate(com, directoryTxgRegionA, regionA, directoryTxgRegionB, regionB, directoryCompare);
        foreach (EvaluationResults eval, results) {
            // User output
            ret.append(eval.toString());
            // Add to pivot
            QString ID = QString("%1_%2_%3").arg(style).arg(regionA).arg(regionB);
            d->resultsPivot[style][ID].insertions += eval.insertions;
            d->resultsPivot[style][ID].deletions  += eval.deletions;
            d->resultsPivot[style][ID].phonemesLessThan20ms += eval.phonemesLessThan20ms;
            d->resultsPivot[style][ID].phonemesLessThan40ms += eval.phonemesLessThan40ms;
            d->resultsPivot[style][ID].phonemesTotal        += eval.phonemesTotal;
        }
    }
    if (!ret.isEmpty()) ret.chop(1);
    return ret;
}

void PFCAlignmentEvaluation::pivotReset()
{
    d->resultsPivot.clear();
    foreach (QString regionA, d->regionCodes) {
        foreach (QString regionB, d->regionCodes) {
            if (regionA == regionB) continue;
            foreach (QString style, d->styles) {
                EvaluationResults eval;
                eval.ID = QString("%1_%2_%3").arg(style).arg(regionA).arg(regionB);
                eval.groupID = style;
                eval.regionData = regionA;
                eval.regionModel = regionB;
                d->resultsPivot[style].insert(eval.ID, eval);
            }
        }
    }
}

QStringList PFCAlignmentEvaluation::pivotList(const QString &style)
{
    if (!d->resultsPivot.contains(style)) return QStringList();
    QStringList ret;
    foreach (QString regionA, d->regionCodes) {
        foreach (QString regionB, d->regionCodes) {
            if (regionA == regionB) continue;
            QString ID = QString("%1_%2_%3").arg(style).arg(regionA).arg(regionB);
            ret << d->resultsPivot[style][ID].toString();
        }
    }
    return ret;
}

QStringList PFCAlignmentEvaluation::pivotTable(const QString &style, int tolerance)
{
    if (!d->resultsPivot.contains(style)) return QStringList();
    if ((tolerance != 20) && (tolerance != 40)) return QStringList();
    QStringList ret;
    foreach (QString regionA, d->regionCodes) {
        QString line;
        line.append(regionA);
        foreach (QString regionB, d->regionCodes) {
            if (regionA == regionB) { line.append("\t1.0"); continue; }
            QString ID = QString("%1_%2_%3").arg(style).arg(regionA).arg(regionB);
            double p = (tolerance == 20) ? d->resultsPivot[style][ID].percentageLessThan20ms() :
                                           d->resultsPivot[style][ID].percentageLessThan40ms();
            line.append("\t").append(QString::number(p));
        }
        line.append("\n");
        ret << line;
    }
    return ret;
}
